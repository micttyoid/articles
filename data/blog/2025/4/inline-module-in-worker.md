---
title: 'Optimizing Cloudflare Workers: Inline Small Modules for Leaner Webpack Bundles'
date-published: 2025-04-16
date-drafted: 2025-04-10
date-modified: null
author:
  - name: Luke Yoo
  - email: w.lukeyoo@gmail.com
  - website1: https://github.com/micttyoid
tags:
  - Cloudflare
  - Wrangler
  - Optimization
  - Optimisation
  - JavaScript
  - Webpack
  - Inline
---

# Optimizing Cloudflare Workers: Inline Small Modules for Leaner Webpack Bundles

> It does inline by itself. Does it do well?

> What made them ["Just use Vite"](https://blog.cloudflare.com/introducing-the-cloudflare-vite-plugin)?

**Abstractoid**

Measurements of a 298-module web worker showed Webpack's inline bundling
yielded 14.92% smaller payloads and 8ms faster starts versus Wrangler's
default inline processing. This demonstrates compile-time optimization's
value for dependency-heavy edge workers.

**Heuristic**

Inline modules when:
- Worker is bundled by Webpack, to be deployed by Wrangler of Cloudflare
- Application carries 100 modules or more
- Modules in size of ~5KB

**Numbers**
| Metric                               | Before | After        |      |
|--------------------------------------|--------|--------------|------|
| Size<sup>1</sup> <sup>2</sup>| 1522.93 KiB | 1295.78 KiB  |   14.92% improvement   |
| Cold Start   | 32ms   | 24ms   | 25.0% improvement|

<sup>1</sup> Although the application is SSR (no client-side bundle),
the metric demonstrates its build-time optimization efficiency.

<sup>2</sup> For the fairness, it was re-conducted with neither asset
nor the dummy file, found in the latter topic. With asset / dummy, the
profiles resulted in 2998.69 KiB to 1295.78 KiB (56.8%).
Startup 33ms to 24ms (27.3%)

## Table of Contents

- [Bundle internal](#bundle-internal)
- [Module group](#module-group)
- [Methodology and Environment](#methodology-and-environment)

## Bundle internal

The following example is of `prism-rust.min.js`, generated by Wrangler and Webpack.

### By Wrangler, that supposedly takes care of it <sup>3</sup>

#### Import logic: misunderstand a dummy file<sup>4</sup> for Tailwind

This section of code shows that Wrangler includes a dummy file, `_ignore.txt` in its import logic as another module. Although the case was excluded in the benchmark, it is worth to note the current Wrangler can be improved by giving such user-side optional configuration.

```js
// Associate unrelated files for some reason
"./8624._ignore.txt": () => Promise.resolve().then(() => __toESM(require_ignore253())),

"./8624.js": () => Promise.resolve().then(() => (init__253(), __exports253)),

var require_ignore299 = __commonJS({
  "../dist/_ignore.txt"(exports, module) {
    module.exports = `/******/ var __webpack_modules__ = ({
    ...
  "./prism-rust.min.js": [
		8624,
		8624
	],
    ...
  `
```

<sup>3</sup> https://developers.cloudflare.com/workers/wrangler/migration/v1-to-v2/eject-webpack/#i-use-type--webpack-but-do-not-provide-my-own-configuration-and-let-wrangler-take-care-of-it

<sup>4</sup> Independent bundling through a JavaScript file that imports in selective manner for finer control over Tailwind extraction and benchmarking.

#### Polyfill: chunks get bulky

Chunking on module is flattened in the following manner:

```js filename="worker.js"
// ../dist/8624.js
var __exports253 = {};
__export(__exports253, {
  __webpack_id__: () => __webpack_id__253,
  __webpack_ids__: () => __webpack_ids__253,
  __webpack_modules__: () => __webpack_modules__253
});
var __webpack_id__253, __webpack_ids__253, __webpack_modules__253;
var init__253 = __esm({
  "../dist/8624.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __webpack_id__253 = 8624;
    __webpack_ids__253 = [8624];
    __webpack_modules__253 = { 8624: () => {
      !function(e2) {
        for (var a2 = "/\\*(?:[^*/]|\\*(?!/)|/(?!\\*)|<self>)*\\*/",
        t3 = 0; t3 < 2; t3++) a2 = a2.replace(/<self>/g,
        function() {
          return a2;
        });
        a2 = a2.replace(/<self>/g, function() {
          return "[^\\s\\S]";
        }), e2.languages.rust = { 
          /* .. rust syntax data ... */
      }(Prism);
    } };
  }
});
```

### By Webpack with explicit inline

#### Import logic
```js
var r2 = {
    "./prism-abap.min.js": 720, 
    /* ... other modules ... */
    "./prism-rust.min.js": 8624,
     /* ... more ... */
  };
  function a2(e4) {
    return i2(e4).then((e5) => n2.t(e5, 23));
  }
  __name(a2, "a");
  function i2(e4) {
    return Promise.resolve().then(() => {
      if (!n2.o(r2, e4)) {
        var t3 = new Error("Cannot find module '" + e4 + "'");
        throw t3.code = "MODULE_NOT_FOUND", t3;
      }
      return r2[e4];
    });
  }
```

#### Polyfill: leverage in chunks
```js
 /* ... */ {{
}, 8606: () => {
    /* ... */
}, 8624: () => {
  !function(e3) {
    for (var t2 = "/\\*(?:[^*/]|\\*(?!/)|/(?!\\*)|<self>)*\\*/", 
        n2 = 0; n2 < 2; n2++) 
      t2 = t2.replace(/<self>/g, function() {
      return t2;
    });
    t2 = t2.replace(/<self>/g, function() {
      return "[^\\s\\S]";
    }), e3.languages.rust = { 
        /* .. same rust syntax data ... */
  }(Prism);
}, 8653: () => {
   /* ... */
}
```

## Module group

> Many & Tiny

**Summary**: Modules of size under 5KB in bulk <sup>5</sup>

**Population**: 298 sub modules <sup>6</sup> from PrismJS

**Example**:

| sub module              | Size        | Note     |
|-------------------------|-------------|----------|
| prism-cpp.min.js        | 2.54KB      |          |
| prism-javascript.min.js | 4.5KB       |          |
| prism-regex.min.js      | 1.26KB      |          |
| prism-rust.min.js       | 2.41KB      |          |

<sup>5</sup> Sub modules of 298 entries, Mean 2.50 KB, Median 1.41KB, Range 
from 0.14KB to 32.72 KB, Total Size 744.44KB(K in 1024 byte).

<sup>6</sup> https://codeberg.org/mictty/articles/raw/branch/main/static/reference/prism-module-sizes_2025-04-10.csv


## Methodology and Environment

**Relavant dependencies of the application**

- babel-loader: v10.0.0
- webpack: v5.98.0 
- webpack-node-externals: v3.0.0
- wrangler: v4.10.0

**Profile and scenario**

The startup time were measured via Wrangler's default profiler, on the 
application, Promenade (v0.1.3).

When its main routine routes to `/blog/*`, an API call is made. On success,
the data is parsed and the following method `highlight_prism` is called 
if needed.

**Used method**

```js
var prism // global
//let prism // module
async function highlight_prism(code, lang) {
	//let prism // single
    if (!prism) {
        prism = await import('prismjs')
    }

    if (!prism.languages[lang]) {
        try {
            await import(`prismjs/components/prism-${lang}.min.js`)
        } catch (e) {
            logger.warn(
                `Prism '${lang}' is not found. Fallback to text: ${e}`
            )
            return code
        }
    }
    return prism.highlight(code, prism.languages[lang], lang)
}
// Forbidden JS snake casing is my only preference ...
```
